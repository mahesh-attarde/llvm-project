; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=x86_64-linux | FileCheck %s -check-prefixes=X64
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -global-isel | FileCheck %s -check-prefixes=GISEL


; FIXME: This is only for code review until all changes are pushed.
; we will reuse isfpclass.ll and isfpclass-f80.ll

define i1 @is_fcNone_f32(float %x) nounwind {
; X64-LABEL: is_fcNone_f32:
; X64:       # %bb.0: # %entry
; X64-NEXT:    xorl %eax, %eax
; X64-NEXT:    retq
;
; GISEL-LABEL: is_fcNone_f32:
; GISEL:       # %bb.0: # %entry
; GISEL-NEXT:    xorl %eax, %eax
; GISEL-NEXT:    retq
entry:
    %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 0)
    ret i1 %0
}

define i1 @is_fcAllFlags_f32(float %x) nounwind {
; X64-LABEL: is_fcAllFlags_f32:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movb $1, %al
; X64-NEXT:    retq
;
; GISEL-LABEL: is_fcAllFlags_f32:
; GISEL:       # %bb.0: # %entry
; GISEL-NEXT:    movb $1, %al
; GISEL-NEXT:    retq
entry:
    %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 1023)
    ret i1 %0
}

define i1 @is_fcNone_f64(double %x) nounwind {
; X64-LABEL: is_fcNone_f64:
; X64:       # %bb.0: # %entry
; X64-NEXT:    xorl %eax, %eax
; X64-NEXT:    retq
;
; GISEL-LABEL: is_fcNone_f64:
; GISEL:       # %bb.0: # %entry
; GISEL-NEXT:    xorl %eax, %eax
; GISEL-NEXT:    retq
entry:
    %0 = tail call i1 @llvm.is.fpclass.f64(double %x, i32 0)
    ret i1 %0
}

define i1 @is_fcAllFlags_f64(double %x) nounwind {
; X64-LABEL: is_fcAllFlags_f64:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movb $1, %al
; X64-NEXT:    retq
;
; GISEL-LABEL: is_fcAllFlags_f64:
; GISEL:       # %bb.0: # %entry
; GISEL-NEXT:    movb $1, %al
; GISEL-NEXT:    retq
entry:
    %0 = tail call i1 @llvm.is.fpclass.f64(double %x, i32 1023)
    ret i1 %0
}

define i1 @is_fcNone_f80(x86_fp80 %x) nounwind {
; X64-LABEL: is_fcNone_f80:
; X64:       # %bb.0: # %entry
; X64-NEXT:    xorl %eax, %eax
; X64-NEXT:    retq
;
; GISEL-LABEL: is_fcNone_f80:
; GISEL:       # %bb.0: # %entry
; GISEL-NEXT:    xorl %eax, %eax
; GISEL-NEXT:    retq
entry:
%0 = tail call i1 @llvm.is.fpclass.f80(x86_fp80 %x, i32 0)
ret i1 %0
}

define i1 @is_fcAllFlags_f80(x86_fp80 %x) nounwind {
; X64-LABEL: is_fcAllFlags_f80:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movb $1, %al
; X64-NEXT:    retq
;
; GISEL-LABEL: is_fcAllFlags_f80:
; GISEL:       # %bb.0: # %entry
; GISEL-NEXT:    movb $1, %al
; GISEL-NEXT:    retq
entry:
    %0 = tail call i1 @llvm.is.fpclass.f80(x86_fp80 %x, i32 1023)
    ret i1 %0
}
